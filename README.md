# Собеседование, пройденное мной в августе 2021 года

## Задача

Реализовать API с одним методом - добавление новой задачи
Передаваемые параметры - Description:String - описание задачи
Необходимо реализовать функциональность приема этих задач и создания записи в БД Postgres. Сервис(ы) должны обеспечивать прием заявок в многопоточном режиме. Для каждой задачи создается ID:Integer с циклическим инкрементом, инициализация с 0 при старте сервиса. В БД передается Id - сгенерированный идентификатор, Description - описание задачи, Dt - текущая дата и время
Репозиторий и процедуру записи в БД реализовывать не надо, только декларация.

## Решение

Реализовал с использованием брокера сообщений **RabbitMQ**.

API добавления новой задачи реализовано в проекте **Homework.PresentationLayer.RabbitMQ.Producer**. Полученное от пользователя описание задачи отправляется в очередь внутри метода **Post** класса **TaskController** пространства имён **Homework.PresentationLayer.RabbitMQ.Producer.Controllers**.

Процедура отправки заявок в очередь реализована в классе **Service** пространства имён **Homework.ApplicationLayer.RabbitMQ.Producer**.

Приём заявок реализован в проекте **Homework.PresentationLayer.RabbitMQ.Consumer**. Описание задачи в несколько потоков забирается из очереди, путём потокобезопасного инкремента генериуется идентификатор задачи и всё это вместе с текущей датой и временем отправляется в таблицу **task** базы данных **PostgreSQL**.

Процедура изъятия сообщений из очереди реализована в классе **Service** пространства имён **Homework.ApplicationLayer.RabbitMQ.Consumer**.

Запуск нескольких потоков с этой процедурой реализован в классе **Worker** пространства имён **Homework.PresentationLayer.RabbitMQ.Consumer**.

Процедура сохранения записи в таблицу заменена задержкой в 5 секунд для имитации долгой работы. Имитация записи в базу данных реализована в классе **DomainService** пространства имён **Homework.DomainLayer.Domains.Task**.

Так как была просьба продемонстрировать архитектурное решение, я сделал строгое разделение функциональности по слоям. Каждый из 13 проектов в решении относится только к одному архитектурному слою. Всего таких слоёв 6. Название слоя присутствует в имени каждого проекта:

1. **InfrastructureLayer** - слой инфрастуктуры
1. **DataLayer** - слой данных
1. **DataAccessLayer** - слой доступа к данным
1. **DomainLayer** - доменный слой
1. **ApplicationLayer** - слой приложения
1. **PresentationLayer** - слой пользовательского интерфейса

Каждый нижележащий слой в этом списке зависит только от вышележащих.

Прототипом этого решения послужил код из папки **server/src** репозитория [Makc2021](https://github.com/maxim-kuzmin/Makc2021/tree/main/server/src). Там эти слои помечены номерами, то есть вместо **InfrastructureLayer** используется **Layer1**, а вместо **PresentationLayer** - **Layer6**.

Так как в задании указывалось конкретное название базы данных, я добавил в решение проекты, предназначенные для настройки ORM **Entity Framework** на работу с этим типом СУБД. Эти проекты содержат в своём имени слово **DataAccessLayer**. Архитектура построена так, чтобы можно было реализовать одну и ту же модель данных с использованием различных СУБД. ORM для конкретной СУБД настраивается в проекте, содержащем в своём имени названия СУБД и библиотеки, используемой для ORM, то есть это, соответственно, **PostgreSql** и **EF** (сокращение от **Entity Framework**). Полное имя проекта выглядит так: **Homework.DataAccessLayer.Database.Clients.PostgreSql.EF**.
